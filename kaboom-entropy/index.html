<!DOCTYPE html>
<html>

<head>
    <title>Kaboomlaser Entropy</title>
    <!-- STYLE SHEETS-->
    <link rel="stylesheet" type="text/css" href="css/experiments.css" />
    <link rel="stylesheet" type="text/css" href="css/gradientui.css" />
    <link type="text/css" href="css/jquery-ui-1.8.16.custom.css" rel="stylesheet" />
    <!--  LIBRARIES -->
    <script type="text/javascript" src="js/jquery/jquery-1.6.2.min.js"></script>
    <script type="text/javascript" src="js/jquery/jquery-ui-1.8.16.custom.min.js"></script>
    <!--<script type="text/javascript" src="js/three/three.js"></script>-->
    <script type="text/javascript" src="js/three/three.min_new.js"></script>
    
   <!-- <script type="text/javascript" src="js/three/OBJLoader.js"></script>-->

    <!-- CODE -->
    <script type="text/javascript" src="js/entropy/gradientui.js"></script>
    <script type="text/javascript" src="js/entropy/colorPicker.js"></script>
    <script type="text/javascript" src="js/entropy/grayscott.js"></script>


    <script type="x-shader/x-vertex" id="standardVertexShader">
        varying vec2 vUv;
        
        void main()
        {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>

<script type="x-shader/x-fragment" id="gsFragmentShader">
        varying vec2 vUv;
        uniform float screenWidth;
        uniform float screenHeight;
        uniform sampler2D tSource;
        uniform float delta;
        uniform float feed;
        uniform float kill;
        
        
        
        uniform vec2 brush;
        uniform float brmode;

        vec2 texel = vec2(1.0/screenWidth, 1.0/screenHeight);
        float step_x = 1.0/screenWidth;
        float step_y = 1.0/screenHeight;
        
        
        
  /* Simplex noise function */
  vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }
  float snoise(vec2 v) {
    const vec4 C = vec4(0.211324865405187, 0.366025403784439,
                       -0.577350269189626, 0.024390243902439);
    vec2 i  = floor(v + dot(v, C.yy) );
    vec2 x0 = v -   i + dot(i, C.xx);
    vec2 i1;
    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    vec4 x12 = x0.xyxy + C.xxzz;
    x12.xy -= i1;
    i = mod(i, 289.0);
    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
                     + i.x + vec3(0.0, i1.x, 1.0 ));
    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
                                             dot(x12.zw,x12.zw)), 0.0);
    m = m*m ;
    m = m*m ;
    vec3 x = 2.0 * fract(p * C.www) - 1.0;
    vec3 h = abs(x) - 0.5;
    vec3 ox = floor(x + 0.5);
    vec3 a0 = x - ox;
    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
    vec3 g;
    g.x  = a0.x  * x0.x  + h.x  * x0.y;
    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
    return 130.0 * dot(m, g);
  }

  vec2 homogen_uv()
  {
    float sqrt_F = sqrt(feed);
    float U = 1.0;
    float V = 0.0;
    if (kill < (sqrt_F - 2.0 * feed) / 2.0) {
      float A = sqrt_F / (feed + kill);
      U = (A - sqrt(A*A - 4.0)) / (2.0 * A);
      U = clamp(U, 0.0, 1.0);
      V = sqrt_F * (A + sqrt(A*A - 4.0)) / 2.0;
      V = clamp(V, 0.0, 1.0);
    } // else, (U,V) already set to (1,0)
    return vec2(U, V);
  }
        
        
        
        
        
        
        
        
        
        
        
        
        
        void main()
        {
                      if (brush.x < -5.0) {
                  /* This means the "clear" command was just given */
                  vec2 huv = homogen_uv();
                  if (brush.y < -5.0) {
                    // Set to red state
                    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); /* u=1, v=0, -, opaque */
                  } else if (brush.y < 0.0) {
                    // set to blue state
                    gl_FragColor = vec4(huv.r, huv.g, 0.0, 1.0);
                  } else if (brush.y == 2.0) {
                    // let's do some noise
                    // float t = 0.5*(snoise(0.21*vUv/texel) + snoise(0.34*vUv/texel));
                    float t = 0.5*(snoise(0.1*vUv/texel) + snoise(0.16*vUv/texel));
                    gl_FragColor = vec4(clamp(huv.r-t, 0.0, 1.0),
                                        clamp(huv.g+t, 0.0, 1.0), 0.0, 1.0);
                  } else {
                    // works for most of the presets, but is worse for a couple of them
                    float t1 = 0.5*(snoise(0.1*vUv/texel) + snoise(0.16*vUv/texel));
                    float t2 = 0.5*(snoise(0.3-0.13*vUv/texel)
                                                         + snoise(0.7-0.21*vUv/texel));
                    gl_FragColor = vec4(clamp(huv.r-0.25+t1, 0.0, 1.0),
                                        clamp(huv.g-0.25+t2, 0.0, 1.0), 0.0, 1.0);
                  }
                  return;
                }
            
            //float feed = vUv.y * 0.083;
            //float kill = vUv.x * 0.073;
            
         vec2 uv = texture2D(tSource, vUv).rg;
            vec2 uv0 = texture2D(tSource, vUv+vec2(-step_x, 0.0)).rg;
            vec2 uv1 = texture2D(tSource, vUv+vec2(step_x, 0.0)).rg;
            vec2 uv2 = texture2D(tSource, vUv+vec2(0.0, -step_y)).rg;
            vec2 uv3 = texture2D(tSource, vUv+vec2(0.0, step_y)).rg;               
            vec2 lapl = (uv0 + uv1 + uv2 + uv3 - 4.0*uv);//10485.76;
            
            float Da;
            float Db;
            Da=0.2097;  // original
            Db=0.105;    // original
            
        
            
            float du = /*0.00002*/Da*lapl.r - uv.r*uv.g*uv.g + feed*(1.0 - uv.r);
            float dv = /*0.00001*/Db*lapl.g + uv.r*uv.g*uv.g - (feed+kill)*uv.g;


            // enable this for circular cut-off
            float R=sqrt( (vUv.x-0.5)*(vUv.x-0.5) + (vUv.y-0.5)*(vUv.y-0.5) );
       //     if (R>0.4) {
       //         //du=0.0;
       //         dv=0.00;
        //   }

            vec2 dst = uv + delta*vec2(du, dv);
            
            if ((R>0.48 )|| (R<0.125)) {
                dst.r=1.0;
                dst.g=1.0;
                //dv=0.00;
           }


            if(brush.x > 0.0)
            {
                vec2 diff = (vUv - brush)/texel;
                float dist = dot(diff, diff);
                if(dist < 5.0) {
                    dst.g = 0.9;
                    if (brmode > 0.0) {
                        /* paint blue */
                        dst.r = 0.0; dst.g = 0.9; /* set u=0, v=0.9 */
                      } else {
                        /* paint red */
                        dst.r = 1.0; dst.g = 0.0; /* set u=1, v=0 */
                      }
                }
            }
            
            gl_FragColor = vec4(dst.r, dst.g, 0.0, 1.0);
        }
        
        
        
        
        
        
        
    </script>
<script type="x-shader/x-fragment" id="screenFragmentShader">
        varying vec2 vUv;
        uniform float screenWidth;
        uniform float screenHeight;
        uniform sampler2D tSource;
        uniform float delta;
        uniform float feed;
        uniform float kill;
        uniform vec4 color1;
        uniform vec4 color2;
        uniform vec4 color3;
        uniform vec4 color4;
        uniform vec4 color5;
        
        vec2 texel = vec2(1.0/screenWidth, 1.0/screenHeight);
        
        void main()
        {
            float value = texture2D(tSource, vUv).g;
            //int step = int(floor(value));
            //float a = fract(value);
            float a;
            vec3 col;
            
            if(value <= color1.a)
                col = color1.rgb;
            if(value > color1.a && value <= color2.a)
            {
                a = (value - color1.a)/(color2.a - color1.a);
                col = mix(color1.rgb, color2.rgb, a);
            }
            if(value > color2.a && value <= color3.a)
            {
                a = (value - color2.a)/(color3.a - color2.a);
                col = mix(color2.rgb, color3.rgb, a);
            }
            if(value > color3.a && value <= color4.a)
            {
                a = (value - color3.a)/(color4.a - color3.a);
                col = mix(color3.rgb, color4.rgb, a);
            }
            if(value > color4.a && value <= color5.a)
            {
                a = (value - color4.a)/(color5.a - color4.a);
                col = mix(color4.rgb, color5.rgb, a);
            }
            if(value > color5.a)
                col = color5.rgb;
            
            gl_FragColor = vec4(col.r, col.g, col.b, 1.0);
        }
    </script>







    <meta charset="UTF-8">
    <style>
        #gradient {
            height: 40px;
            width: 85%;
            margin-top: 5px;
            margin-left: auto;
            margin-right: auto;
        }
    </style>
    <script>
        $(function () {
            $("#gradient").gradient({
                values:
                    [[0, '#000000'],
                    [0.2, '#00FF00'],
                    [0.21, '#FFFF00'],
                    [0.4, '#FF0000'],
                    [0.6, '#FFFFFF']]
            });

            // KLUDGE!
            colorPicker.offsetX = -512;
            colorPicker.offsetY = -256;
            document.getElementById("gradient").onselectstart = function () { return false; };
            loadshaders();
           //init();
        });
    </script>
</head>

<body>

    <header>
        <h1>Reaction diffusion system (Gray-Scott model)</h1>
    </header>
    <div id="simulation">
        <canvas id="myCanvas" class="viewer" style="width:1024px;height:1024px"></canvas>
        <aside class="panel">
            <section id="instructions">
                <header>
                    <h4>Instructions</h4>
                </header>
                <ol>
                    <li>Paint some strokes on the canvas.</li>
                    <li>Choose the evolution settings with the controls below.</li>
                    <li>Watch the evolution.</li>
                </ol>
            </section>
            <section id="controls">
                <!--header><h4>Controls</h4></header-->
                <form name="ex">
                    Presets:
                    <select name="scene" style="width:100%" onchange="loadPreset(document.ex.scene.selectedIndex)">
                        <option value="0">Negative bubbles (sigma)</option>
                        <option value="1">Bubbles (rho)</option>
                        <option value="2">Precritical bubbles (rho/kappa)</option>
                        <option value="3" selected="selected">Worms and loops (kappa)</option>
                        <option value="4">Stable solitons (nu)</option>
                        <option value="5">The U-Skate world (pi)</option>
                        <option value="6">Worms (mu)</option>
                        <option value="7">Worms join into maze (kappa)</option>
                        <option value="8">Negatons (iota)</option>
                        <option value="9">Turing patterns (delta)</option>
                        <option value="10">Chaos to Turing negatons (beta)</option>
                        <option value="11">Fingerprints (theta/kappa)</option>
                        <option value="12">Chaos with negatons (beta/delta)</option>
                        <option value="13">Spots and worms (eta)</option>
                        <option value="14">Self-replicating spots (lambda)</option>
                        <option value="15">Super-resonant mazes (theta)</option>
                        <option value="16">Mazes (kappa)</option>
                        <option value="17">Mazes with some chaos (gamma)</option>
                        <option value="18">Chaos (beta)</option>
                        <option value="19">Pulsating solitons (zeta)</option>
                        <option value="20">Warring microbes (epsilon)</option>
                        <option value="21">Spots and loops (alpha)</option>
                        <option value="22">Moving spots (alpha)</option>
                        <option value="23">Waves (xi)</option>

                    </select>
                </form>
                <p style="text-align:center">
                    <button id="btn_clear" onclick="clean()">Clear</button>
                    <button id="btn_snapshot" onclick="snapshot()">Take snapshot</button>
                    <button id="btn_fullscreen" onclick="fullscreen()">Fullscreen mode</button>
                    <p />
                <h4 class="unsafe">Advanced settings</h4>
                Feed rate:
                <span class="remark" id="replenishment"></span><br />
                <div id="sld_replenishment" class="slider"></div>

                Death rate:
                <span class="remark" id="diminishment"></span><br />
                <div id="sld_diminishment" class="slider"></div>
                Colors:
                <div id="gradient" style=""></div>
                <div style="font-size:x-small">Share (paste and press enter):</div>
                <div style="text-align:center"><input id="share" style="width:85%" /></div>
            </section>
        </aside>
    </div>
    <footer>
        <div id="copyright">
            &copy;2012
            <a href="https://twitter.com/pmneila">@pmneila</a>
            <a href="https://github.com/pmneila/jsexp">Github</a>
            <a id="notworking" href="#">Not working?</a>
        </div>
    </footer>

    <div id="requirement_dialog" title="Requirements">
        <p>This simulation requires the GL extensions framebuffer_object and texture_float.
            If you cannot see the simulation your system probably lacks at least one of these extensions.</p>

        <p>In Google Chrome, you can see the available GL extensions going to chrome://gpu.</p>
    </div>
</body>

</html>