<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - svg loader</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
	<style>
		body {
			background-color: #b0b0b0;
		}
	</style>
</head>

<body>
	<div id="container"></div>
	<div id="info">
		<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - SVGLoader
	</div>
	<script type="module">
		import * as THREE from '../js/three.module.js';
		import Stats from './js/stats.module.js';
		import { GUI } from './js/dat.gui.module.js';
		import { OrbitControls } from './js/OrbitControls.js';
		import { SVGLoader } from './js/SVGLoader.js';

		var renderer, stats, scene, camera, gui, guiData, material, texture;

		init();
		animate();
		//---------------------------------------------------------------------------------------------------------------------
		function init() {
			var container = document.getElementById('container');

			//
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.shadowMapEnabled = true;
			renderer.shadowMapType = THREE.PCFSoftShadowMap;
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.toneMapping = THREE.Uncharted2ToneMapping;
			renderer.toneMapingExposure = 1;
			renderer.toneMappingWhitePoint = .9;
			container.appendChild(renderer.domElement);
			//

			//
			//			stats = new Stats();
			//			container.appendChild(stats.dom);
			//
			window.addEventListener('resize', onWindowResize, false);

			guiData = {
				currentURL: 'models/svg/sample.svg',
				extrudeGeometry: true,
				offsetX: 0,
				offsetY: 0,
				repeatX: 0.005,
				repeatY: 0.005,
				rotation: Math.PI / 4, // positive is counter-clockwise
				centerX: 0.5,
				centerY: 0.5,
				camX: 0,
				camY: -153,
				camZ: 200
			};

			camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
			camera.position.set(guiData.camX, guiData.camY, guiData.camZ);
			var controls = new OrbitControls(camera, renderer.domElement);
			controls.screenSpacePanning = true;




			loadSVG(guiData.currentURL);
			createGUI();
		}
		//---------------------------------------------------------------------------------------------------------------------
		function updateUvTransform() {
			if (texture.matrixAutoUpdate === true) {
				texture.offset.set(guiData.offsetX, guiData.offsetY);
				texture.repeat.set(guiData.repeatX, guiData.repeatY);
				texture.rotation = guiData.rotation; // rotation is around [ 0.5, 0.5 ]
			} else {
				// one way...
				//texture.matrix.setUvTransform( API.offsetX, API.offsetY, API.repeatX, API.repeatY, API.rotation, API.centerX, API.centerY );
				// another way...
				texture.matrix
					.identity()
					.translate(- guiData.centerX, - guiData.centerY)
					.rotate(guiData.rotation)					// I don't understand how rotation can preceed scale, but it seems to be required...
					.scale(guiData.repeatX, guiData.repeatY)
					.translate(guiData.centerX, guiData.centerY)
					.translate(guiData.offsetX, guiData.offsetY);
			}
			render();
		}
		//---------------------------------------------------------------------------------------------------------------------
		function createGUI() {
			if (gui) gui.destroy();
			gui = new GUI({ width: 350 });
			gui.add(guiData, 'currentURL', {
				"olifant": 'models/svg/olifant.svg',
				"leeuw": 'models/svg/leeuw.svg',
				"wolf": 'models/svg/leeuw.svg',
				"beer": 'models/svg/beer.svg',
				"wolf": 'models/svg/wolf.svg',
				"uil": 'models/svg/uil.svg',
				"catwalk": 'models/svg/catwalk.svg',
				"dolfijn": 'models/svg/dolfijn.svg',
				"koe": 'models/svg/koe.svg',
				"paard": 'models/svg/paard.svg',
				"dieren": 'models/svg/dieren.svg',
				"jachtluipaard": 'models/svg/jachtluipaard.svg',
				"giraffe": 'models/svg/giraffe.svg',
				"kat1": 'models/svg/kat1.svg',
				"buffel": 'models/svg/buffel.svg',
				"neushoorn": 'models/svg/neushoorn.svg',
				"konijn": 'models/svg/konijn.svg',
				"big5+1": 'models/svg/big5+1.svg',
				"sneeuwvlok": 'models/svg/sneeuwvlok.svg',
				"Three.js": 'models/svg/threejs.svg',
				"ehv": 'models/svg/ehv.svg',
				"border": 'models/svg/border.svg',
				"Toller": 'models/svg/toller.svg',
				"Joins and caps": 'models/svg/lineJoinsAndCaps.svg',
			}).name('SVG File').onChange(update);
			gui.add(guiData, 'offsetX', 0.0, 1.0).name('offset.x').onChange(updateUvTransform);
			gui.add(guiData, 'offsetY', 0.0, 1.0).name('offset.y').onChange(updateUvTransform);
			gui.add(guiData, 'repeatX', 0.001, 0.01).name('repeat.x').onChange(updateUvTransform);
			gui.add(guiData, 'repeatY', 0.001, 0.01).name('repeat.y').onChange(updateUvTransform);
			gui.add(guiData, 'rotation', - 2.0, 2.0).name('rotation').onChange(updateUvTransform);
			gui.add(guiData, 'centerX', 0.0, 500).name('center.x').onChange(updateUvTransform);
			gui.add(guiData, 'centerY', 0.0, 500).name('center.y').onChange(updateUvTransform);
			gui.add(guiData, 'camX', -500, 500).name('cam.x').onChange(updateUvTransform);
			gui.add(guiData, 'camY', -500, 500).name('cam.y').onChange(updateUvTransform);
			gui.add(guiData, 'camZ', 0.0, 2500).name('cam.z').onChange(updateUvTransform);


			function update() {
				loadSVG(guiData.currentURL);
			}
		}
		//---------------------------------------------------------------------------------------------------------------------
		function loadSVG(url) {
			//
			scene = new THREE.Scene();
			scene.background = new THREE.Color(0xDDDDDD);
			//
			var ttexture = new THREE.TextureLoader().load("img/sbklx0p_4K_AO.jpg");
			var tbump = new THREE.TextureLoader().load("img/sbklx0p_4K_Displacement.jpg");
			ttexture.repeat.set(1, 1);
			tbump.repeat.set(1, 1);
			var tablematerial = new THREE.MeshPhongMaterial({

				color: 0xAFAFAF,
				side: THREE.DoubleSide,
				map: ttexture,
				bump: tbump
				//depthWrite: false,
			});
			var table = new THREE.PlaneGeometry(1000, 1000);
			var tablemesh = new THREE.Mesh(table, tablematerial);
			tablemesh.position.z = -0.5;
			tablemesh.receiveShadow = true;
			//tablemesh.castShadow = true;
			scene.add(tablemesh);

			const light0 = new THREE.AmbientLight(0x101010);
			scene.add(light0);
			const light1 = new THREE.SpotLight(0xFFFFFF);
			light1.position.set(-150, 100, 300);
			light1.castShadow = true;
			light1.shadowCameraVisible = true;
			light1.shadow.mapSize.width = 16384;  // default
			light1.shadow.mapSize.height = 16384; // default
			light1.shadow.camera.near = 0.5       // default
			light1.shadow.camera.far = 1500      // default
			light1.shadowDarkness = 0.5;
			scene.add(light1);
			var spotLightHelper = new THREE.SpotLightHelper(light1);
			//	scene.add(spotLightHelper);



			var helper = new THREE.GridHelper(1000, 10);
			helper.rotation.x = Math.PI / 2;
			//scene.add(helper);
			//
			var loader = new SVGLoader();
			loader.load(url, function (data) {
				var tpaths = data.paths;
				var group = new THREE.Group();
				var path = new THREE.ShapePath();
				for (var i = 0; i < tpaths.length; i++) {
					for (var j = 0; j < tpaths[i].subPaths.length; j++) {
						path.subPaths.push(tpaths[i].subPaths[j]);
					}

				}
				/*
				var material = new THREE.MeshBasicMaterial( {
					color: new THREE.Color().setStyle( fillColor ),
					opacity: path.userData.style.fillOpacity,
					transparent: path.userData.style.fillOpacity < 1,
					side: THREE.DoubleSide,
					depthWrite: false,
					wireframe: guiData.fillShapesWireframe
				} );
				*/

				texture = new THREE.TextureLoader().load("img/plywood1.jpg");
				texture.wrapS = THREE.RepeatWrapping;
				texture.wrapT = THREE.RepeatWrapping;
				texture.repeat.set(0.005, 0.005);
				texture.center.x = 40;
				texture.center.y = 0;
				//texture.offset=(0,0);
				//var material= new THREE.MeshNormalMaterial();
				material = [
					new THREE.MeshStandardMaterial({ map: texture, bumpMap: texture, color: 0xffffff }),
					new THREE.MeshStandardMaterial({ map: texture, color: 0x202020 }),
					new THREE.MeshStandardMaterial({ map: texture, color: 0x202020 }),
				];
				var shapes = path.toShapes(true, false);
				for (var j = 0; j < shapes.length; j++) {
					var shape = shapes[j];
					var geometry = new THREE.ExtrudeGeometry(shape, { depth: 5, bevelEnabled: false });
					var mesh = new THREE.Mesh(geometry, material);
					mesh.castShadow = true;
					mesh.receiveShadow = true;
					group.add(mesh);
				}
				//-- repositioning 
				group.scale.y *= - 1;
				group.castShadow = true;
				var box = new THREE.BoxHelper(group, 0xffff00);
				box.geometry.computeBoundingBox();
				var centerX = (box.geometry.boundingBox.max.x + box.geometry.boundingBox.min.x) / 2;
				var centerY = (box.geometry.boundingBox.max.y + box.geometry.boundingBox.min.y) / 2;
				var centerZ = (box.geometry.boundingBox.max.z + box.geometry.boundingBox.min.z) / 2;
				var dimX = (box.geometry.boundingBox.max.x - box.geometry.boundingBox.min.x);
				var dimY = (box.geometry.boundingBox.max.y - box.geometry.boundingBox.min.y);
				var dimZ = (box.geometry.boundingBox.max.z - box.geometry.boundingBox.min.z);
				group.position.x = -centerX;
				group.position.y = -centerY;
				box.update();
				box.geometry.computeBoundingBox();

				scene.add(group);
			});

		}
		//---------------------------------------------------------------------------------------------------------------------
		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}
		//---------------------------------------------------------------------------------------------------------------------
		function animate() {

			requestAnimationFrame(animate);
			render();

		}
		//---------------------------------------------------------------------------------------------------------------------
		function render() {

			renderer.render(scene, camera);
			guiData.camX = camera.position.x;
			guiData.camY = camera.position.y;
			guiData.camZ = camera.position.z;
			for (var i in gui.__controllers) {
				gui.__controllers[i].updateDisplay();
			}
			//gui.update();

		}

	</script>

</body>

</html>